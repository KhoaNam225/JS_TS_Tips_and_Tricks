<section id="spread-operator" class="sub-section">
  <h1>Spread Operator</h1>
  <p>
    <strong>Syntax: </strong>
    <code class="inline-code">...[variable_name]</code>
  </p>
  <p>
    <strong>Usage: </strong>
    The spread operator is used to expand an iterable (a string, object or an
    array). It provides a handy way to "spread" the content of that iterable to
    be used in a list of some kind.
  </p>
  <p>The following code demonstrates the spread operator's usage:</p>
  <app-code-block [code]="spreadOperatorCodeArray"></app-code-block>

  <p>
    <strong>Use Case - Shallow Copy:</strong> The spread operator can be used to
    conveniently create shallow copies of the contents of arrays and objects. Specifically, the new array/object
    will have new copies (new instances) of any <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" target="_blank">primitive</a>
    values (numbers, strings, booleans, null/undefined etc.). For non-primitive values (e.g. other objects/arrays nested in the original) in the shallow copy,
    only the reference is used (i.e. objects and arrays are shared between the clone and original).
  </p>

  <p>
    For example, consider the below script:
  </p>
  <app-code-block [code]="spreadOperatorUseCaseArrayClone"></app-code-block>

  <p>
    Note that we can also produce a shallow clone using <code class="inline-code">clonedArray = originalArray.concat([])</code>
    or with <code class="inline-code">clonedArray = originalArray.slice()</code>
  </p>

  <p>
    <strong>Use Case - Populating Array and Object Literals: </strong> The above shallow-copying behaviour can be extended
    to quickly and easily build new array literals by spreading existing ones. The order of elements inside the spread array,
    and the order of those elements relative to other elements in the array are preserved:
  </p>
  <app-code-block [code]="spreadOperatorUseCasePopulatingArrayLiterals"></app-code-block>

  <p>
    Similarly, this works for object literals. However as the same key can be used multiple times in the same object literal
    (because of using the spread operator), only the last key-value pair is used for each key.
  </p>
  <app-code-block [code]="spreadOperatorUseCasePopulatingObjectLiterals"></app-code-block>

  <p>
    <strong>Use Case - Spreading arguments:</strong> The same syntax can also be used when specifying ordered arguments to a function
    or method. Specifically, spreading an array will specify arguments in that order. Note that spreading objects to specify arguments
    by key does NOT work (this is usually solved by passing in a single object with all required arguments instead).
  </p>
  <app-code-block [code]="spreadOperatorUseCaseSpreadArguments"></app-code-block>

  <p>
    <strong>Use Case - Collating arguments:</strong> A similar syntax can also be used when defining functions with an unspecified
    number of arguments. With this syntax, all arguments are collated into a single array for use within the function.
  </p>
  <app-code-block [code]="spreadOperatorUseCaseCollateArguments"></app-code-block>
</section>
<section id="destructuring-operator" class="sub-section">
  <h1>Destructuring Operator</h1>
  <p>
    <strong>Syntax: </strong>
    <code class="inline-code">const [var1, var2, var3, ..., varN] = array</code>
    for arrays and
    <code class="inline-code"
      >const &#123; var1, var2, var3, ..., varN &#125; = object</code
    >
    for objects.
  </p>

  <p>
    <strong>Usage: </strong>
    The destructuring operator is quite opposite to the spread operator. Instead
    of expanding the whole content of an array/object, it will 'pick' some
    values in that array/object and assign them to individual variables. For
    example:
  </p>
  <app-code-block [code]="destructuringOperatorFirstExample"></app-code-block>

  <p>
    When working with arrays, the destructuring operator will be useful when we
    want to pick the values at some certain positions that we already know
    beforehand. For example:
  </p>
  <app-code-block [code]="destructuringOperatorArray"></app-code-block>

  <p>
    You might not see the real power of the destructuring operator from the
    example with array above since it is more widely used with objects. This
    operator will give us an incredibly quick way to access the values of
    individual properties of an object. The below example demonstrates how
    destructuring operator is used to avoid writing tedious and duplicated code:
  </p>
  <app-code-block [code]="destructuringOperatorObject"></app-code-block>

  <p>
    Also, destructuring operator gives us a way to selectively choose/remove a
    property from a given object. For example, in the below script, we select
    the value of the <code class="inline-code">year</code> property and assign
    the rest to the <code class="inline-code">theRest</code> object. In other
    words, we have removed the <code class="inline-code">year</code> property
    from the original object!
  </p>
  <app-code-block [code]="destructuringOperatorPickingValue"></app-code-block>

  <p>
    Finally, we can also leverage the destructuring operator to shorten the
    amount of code we need to write to create a function. For example, the below
    function takes in an object of type
    <code class="inline-code">TonnageValue</code> and performs some calculation
    with it. There are 3 different ways to implement this function:
  </p>
  <app-code-block
    [code]="destructuringOperatorWritingFunction"
  ></app-code-block>
</section>
<section id="shorthand-syntax" class="sub-section">
  <h1>Shorthand Syntax</h1>
  <p>
    Apart from the spread and destructuring operators, Javascript ES6+ also
    provide some more useful syntax that can help reduce the amount of code that
    we have to write and make it a lot more readable.
  </p>

  <h2>1. Ternary Operator</h2>
  <p>
    <strong>Syntax: </strong>
    <code class="inline-code"
      >[conditional_statement] : [value_if_true] ? [value_if_false]</code
    >
  </p>
  <p>
    <strong>Usage: </strong>
    The ternary operator is used to return a value base on a particular
    condition. Its main purpose is to replace simple
    <code class="inline-code">if...else...</code> statements and thus reduce the
    amount of code written. For example:
  </p>

  <app-code-block [code]="ternaryOperatorExample"></app-code-block>

  <h2>2. "OR" operator</h2>
  <p>
    <strong>Syntax: </strong>
    <code class="inline-code">
      [variable_x] || [value_to_return_if_x_is_falsy]</code
    >
  </p>
  <p>
    In some situations, we might need to check if a certain variable has falsy
    value (<code class="inline-code">null, NaN, 0, '', undefined</code>) to
    decide if we should use it or another default value.
  </p>

  <p>
    In this case, we can use the ternary operator mentioned in the previous
    section to shorten the code. However, it can be shortened even more if we
    use the OR operator. Like this:
  </p>

  <app-code-block [code]="orOperatorExample"></app-code-block>

  <h2>3. Null-ish Coalescing</h2>
  <p>
    One drawback of the logical OR operator is that it will return the value to
    the right of the operator whenever the value to the left is falsy. However,
    sometimes we might consider <code class="inline-code">''</code> or
    <code class="inline-code">0</code> as accepted values (e.g. tonnage of 0 is
    still a valid number). In those situation, the null-ish coalescing syntax
    will be useful. It will only return the value to the right if the left value
    is either <code class="inline-code">null</code> or
    <code class="inline-code">undefined</code>. For example:
  </p>

  <app-code-block [code]="nullishCoalescingExample"></app-code-block>

  <h2>4. Optional chaining</h2>
  <p>
    When working with an object, sometimes we will need to check if it has a
    certain property or method. If yes, we proceed with using that property or
    method, otherwise we do something else. This can be easily done with an
    <code class="inline-code">if... else...</code> statement to first check for
    the existence of the property/method and then perform some actions
    accordingly:
  </p>

  <app-code-block [code]="chainingOperatorNaiveExample"></app-code-block>

  <p>
    However, if the object is deeply nested, using
    <code class="inline-code">if...else...</code> statements will result in a
    very big chunk of code even if we only want to perform some simple action:
  </p>

  <app-code-block [code]="chainOperatorProblemExample"></app-code-block>

  <p>
    To tackle this problem , we can use the optional chaining syntax. This
    syntax will first check if a property/method exist. If yes, it will move
    continue down the chain, otherwise it will return
    <code class="inline-code">undefined</code> immediately without throwing any
    error. For example:
  </p>

  <app-code-block [code]="chainOperatorFixProblem"></app-code-block>
</section>
<section id="arrow-functions" class="sub-section">
  <h1>Arrow Functions</h1>
  <p>
    In addition to the regular way of defining functions using the <code>function</code> keyword, functions can
    also be defined using <strong>Arrow Syntax</strong>. Arrow functions are particularly convenient when defining
    <strong>callback</strong> functions, for example to use in Array methods.
  </p>

  <p>
    <strong>Syntax: </strong>
    <code class="inline-code">(arg1, arg2, ...) => &#123; return myResult &#125;</code>
  </p>

  <p>The code below shows some of the syntax that can be used when defining arrow functions.</p>

  <app-code-block [code]="arrowFunctionsExample"></app-code-block>

  <p>
    Please note that arrow functions are not the same as functions defined with the <code class="inline-code">function</code> keyword. Some
    differences exist, such as the behaviour of the <code class="inline-code">this</code> keyword, and the inability to define recursive
    arrow functions.
  </p>

</section>
